\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Palveluiden haku palveluorientoituneessa tietojenkäsittelyssä}
\author{Toni Könnilä}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
A.1 [Introductory and Survey],\\
I.7.m [Document and text processing]}}

\keywords{ulkoasu, tiivistelmä, lähdeluettelo}

%\begin{abstract}
%Service-oriented computing (SOC) on ajatusmalli, jossa yhden monoliittisen ohjelman sijaan painotetaan keskenään kommunikoiviin palveluihin. SOC nojaakin hyvin vahvasti SOA-arkkitehtuurimalliin, joka ajaa tätä samaa ideaa. SOA ei kuitenkaan tarjoa itsessään vastauksia siihen miten turvallisuus, palveluiden koordinointi ja ohjelman keskinäinen arkkitehtuuri on rakennettu.
%
%Tässä aineessa keskitytäänkin palveluorientoituneiden arkkitehtuureille tyypillisiin palveluiden hakemiseen (\textit{service discovery}), ja siihen liittyen, palveluiden piilottamiseen (\textit{location transparency}) käyttäjältä. 
%
%\end{abstract}

\mytableofcontents


\section{Abstrakti}

Service-oriented computing (SOC) on ajatusmalli, jossa yhden monoliittisen ohjelman sijaan keskitytään keskenään kommunikoiviin palveluihin. SOC nojaakin hyvin vahvasti palveluorientoituneeseen arkkitehtuurimalliin (myöhemmin SOA), joka ajaa tätä ideaa. SOA ei kuitenkaan tarjoa itsessään vastauksia siihen miten turvallisuus, palveluiden koordinointi ja ohjelman muu arkkitehtuuri on rakennettu.

Tässä aineessa keskitytään palveluorientoituneiden arkkitehtuureiden yhteisiin piirteisiin ja erityisesti palveluidenhakuun (\textit{service discovery}), ja siihen liittyen, palveluiden läpinäkyvyyteen (\textit{location transparency}).

\section{Johdanto}

SOC:in on ajatusmalli, joka painottaa eri palveluiden käyttöä palvelun koostamiseksi. Yleensä lopputuloksena on siis palvelu, jonka ideana on kommunikoida muiden palveluiden kanssa, jotka ovat itsessään alustariippumattomia ja väljästi yhteydessä toisiinsa (\textit{loosely coupled)}. Business-taustaisena ideana SOA:issa (\textit{Service-oriented architectures}) on tuottaa hyvin keskenään toimivia, mahdollisimman atomisia palveluita, jotka ovat uudelleenkäytettäviä, helposti korvattavissa ja ylläpidettävissä tuottaen nopeasti kustannustehokkaita hajautettuja palveluja lyhyellä kehitys-julkaisuikkunalla (\textit{time-to-market}).

Yksittäisen palvelun tehtävä voi olla yksittäinen pyyntö, tai monimutkaisempi businessprosessi, ja tällaisten palveluiden tarjoajat (olipa ne sitten organisaatioita tai yksityishenkilöitä) mahdollistavat ohjelmallisen pääsyn palveluihinsa ja dataansa internetin yli käyttäen standardoituja välitystapoja, käyttäen yleensä XML-perustaisia tai REST-mallin mukaisia HTTP-protokollaan perustuvia rajapintoja käyttäen. Näiden palveluiden tarjoajien (\textit{service providers}) vastuulla on antaa palvelukuvaus ja ylläpitää palvelua, ja antaa palveluun liittyvää teknistä sekä muuta tukea. Palvelua kutsuvat tahot voivat olla muita ohjelmia, tai yksittäisiä tahoja, esimerkiksi kotipalvelin joka pyytää resurssia REST-rajapinnan toteuttavalta palvelulta internetin yli. Tästä seuraa, että näillä näillä palveluilla on tiettyjä vaatimuksia ja edellytyksiä.

\begin{itemize}

\item \textit{Teknologiariippumattomuus}: Palvelun ei kuulu olla liian teknologiariippuvainen, vaan sitä pitää pystyä kutsumaan alalla vallitsevilla työkaluilla ja alan standardien mukaisesti.

\item \textit{heikko linkittyneisyys (loosely coupled)}: palvelun tulee olla irti mahdollisesta kontekstista, ja toimia itsenäisesti (ainakin ulospäin) ilman tietoa muista palveluista tai komponenteista.

%ehkä erota kahdeksi osaksi?

\item \textit{Palvelun haettavuus (service discovery) ja tuki sijaintiläpinäkyvyydelle (location transparency)}: Palveluiden määritykset ja varsinaiset sijaintitiedot tulee olla tallennettuna johonkin - esimerkiksi UDDI repositorioon, ja asiakkailla/tahoilla pitää olla pääsy palveluun tietämättä missä se varsinaisesti sijaitsee.


\end{itemize}

Tässä aineessa keskitytään palveluiden haettavuuteen ja siihen miten se voidaan toteuttaa palveluorientoituneessa arkkitehtuurimallissa.


\section{Palveluorientoitunut arkkitehtuuri}

Perinteisesti SOC:in palvelumalli johon nojataan, on ollut SOA. SOA pyrkii käyttämään erillisiä palveluja koostaakseen monimutkaisiakin ohjelmistoja. Näiden erillisten palvelujen on tarkoitus olla uudelleenkäytettäviä ja joustavia, ja siten nopeuttaa sekä halventaa ohjelmistokehitystä.

Erillinen yksittinen palvelu eroaa ajatusmaailmaltaan monoliittisen arkkitehtuuripuolen mallista tietyissä osa-alueissa. Se on itsenäinen, väljästi linkitetty, uudelleenkäytettävä, itsensä kuvaava ja helposti siirrettävä toiselle alustalle. Monoliittisessa arkkitehtuurissa palvelut on yleensä tiukasti sidottu sovittuihin teknologioihin, ja edelleen sidottuina käytettävän teknologian vaatimuksiin ja rajotteisiin. Ohjelmat ovat tiiviisti linkattuina muihin kirjastoihin, ja yksittäisten luokkien ja palveluiden korvaaminen päätyy lopulta useiden moduulien muokkaamiseen tätä uutta korvaavaa moduulia tukevaksi.

Myös business-mielessä monoliittinen arkkitehtuuri kasvaa usein turhauttavaksi: yhä kasvavan ohjelman monimutkaisuus ja sisäinen linkittyneisyys muodostuu hidasteeksi uusille projektiin liittyville työntekijöille ja vaatii enemmän ja enemmän aikaa ohjelman kokonaisuuden ymmärtämiseksi. Ohjelman luokkien ja palveluiden linkittyneisyys muodostaa myös kokonaisuuden, jota on vaikeampi muokata, jolloin uudelta työntekijältä saattaa jäädä kooditasolla huomiotta tehdä muutokset kaikkiin paikkoihin joihin muutokseen liittyvä moduuli on kytköksissä. Tämä ongelma on usein itseään ruokkiva, ja ongelmat kasaantuvat entisestään, jos koodin laadusta ei pidetä tasaisesti huolta.
Tätä palveluorientoituneisuus sen sijaan yrittää helpottaa rajaamalla palvelut selkeiksi itsenäisiksi kokonaisuuksiksi.

Monoliittisessa arkkitehtuurissa koko ohjelma voidaan nähdä isona siilona, kun taas SOA on yksinkertaisimmillaan infrastruktuuri, joka tukee erillisten palveluiden kommunikointia keskenään standardien protokollien avulla. Myös näiden palveluiden tulee olla löydettävissä alalla vallitsevien standardirajapintojen avulla. Kun nämä osat toimivat, ohjelmat pääsevät tarvittaessa helposti käsiksi näihin palveluihin ilman tarvetta monimutkaisille räätälöidyille kommunikointiprotokollille.

SOA on looginen tapa suunnitella ohjelmistoja joko yksittäisten käyttäjien tarpeeseen, tai rajapinnaksi muille ohjelmistoille. Perinteinen SOA erittelee (kts. Kuva 1.1) osapuolet palvelun jakajaan, palvelua kutsuvaan osapuoleen (asiakas) sekä palvelurekisteriin jonka avulla pyydetty palvelu löydetään.

\textbf{Palveluntarjoajan} vastuulla on antaa palvelukuvaus ja ylläpitää palvelua, ja antaa palveluun liittyvää teknistä sekä muuta tukea. Palveluntarjoajan vastuulla on myös pitää huoli, että palvelu on löydettävissä palvelurekisterin avulla.

\textbf{Palvelua kutsuvat tahot} voivat olla muita ohjelmia, tai yksittäisiä tahoja, esimerkiksi kotipalvelin joka pyytää resurssia REST-rajapinnan (viite) toteuttavalta palvelulta internetin yli.

SOA:lle tyypillisessä skenaariossa palveluntarjoaja rakentaa toteutuksen palvelusta ja antaa sille palvelukuvauksen. Tämän jälkeen julkaisee sen palveluhakutaholle tai rekisterille, jota kautta palvelu on löydettävissä. Palvelua hakeva osapuoli pääsee käsiksi palveluun tällaisen tahon/rekisterin kautta (kuten esimerkiksi UDDI) ja linkittyy palvelukuvauksen avulla palveluntarjoajaan, jonka jälkeen kutsuva osapuoli pääsee kutsumaan palvelutoteutusta. 


%lopuksi sitten se extended soa

Palveluorientoituneet arkkitehtuurit toteuttavat SOC:in ideaa,
mutteivat ota kantaa esimerkiksi turvallisuuteen, transaktioiden hallintaan tai koordinaatioon [viite papazoglouhun]. Tästä syystä onkin kehitelty xSOA (extended SOA) pyramidi [oma liite tähän].

\section{Palveluorientoituneiden arkkitehtuurien haittapuolet}

\section{Palveluiden haku}

\subsection{Yleisesti}
Palveluntarjoajilla on hallussaan toteutus palvelusta, jota he ylläpitävät ja he myös määrittävät palvelukuvauksen tarjoamalleen palvelulle. Palvelukuvausten tarkoituksena on ilmoittaa palvelun tarkoituksesta, käyttäytymisestä, laadusta ja sen tulee muodostaa alusta löydettävyydelle, linkittymiselle ja palvelukompositiolle. Palvelut voivat tarvittaessa olla yhteydessä toisiinsa monimutkaisemmissa prosesseissa, kuten vaikkapa luottokortin tarkistuksessa tai tuotteen tilauksessa. Koska nämä palvelut ovat luonteeltaan alustariippumattomia, luo se puitteet kompositiopalveluiden tuottamiselle liittämällä yhteen toiminnaltaan yksinkertaisia tai monimutkaisempia palveluita. 

Web service -malli koostuu kolmesta komponentista: asiakkaasta, palveluntarjoajasta sekä rekisteristä. Palveluiden haun kannalta nämä kaikki ovat oleellisia. Ilman rekisteriä kutsujaa ja tarjoajaa ei voida linkittää, koska yleensä asiakas ei tiedä missä palvelu sijaitsee. Palveluntarjoaja julkaisee palvelun rekisterissä luomalla WSDL (Web Service Description Language) määrityksen, joka on XML-pohjainen rajapintakuvaus [viite: Subset WSDL to access Subset Service for Analysis Animesh Chaturvedi], joka kertoo kutsuvalle taholle miten pyydettyä palvelua voidaan kutsua, millaisia parametreja se odottaa, missä muodossa vastaus tulee ja millaisissa tietorakenteissa vastauksen sisältö on [viite: http://www.w3.org/TR/wsdl20-primer]. Perinteisesti nämä tahot ovat keskustelleet keskenään SOAP:n avulla.
SOAP on protokolla, joka alkujaan oli akronyymi sanoista Simple Object Access Protocol. Myöhemmissä versioissa päätettiin ettei SOAP ole akronyymi ollenkaan.

SOAP luotiin toimimaan HTTP-protokollan yli, koska sitä tuetaan kaikissa internet selaimissa ja tarjoaa muodon, jolla XML viestit kääritään .
%(viite http://www.w3schools.com/xml/xml_soap.asp)
Näin kaikki palvelut, jotka
 tukevat SOAP:ia voivat keskustella keskenään, eikä ole väliä miten palvelut ovat teknisesti toteutettu. Rekisterissä on siis WSDL-kuvaus palvelusta. Web service -mallissa asiakastaho tekee pyynnön rekisteriin, jonka jälkeen rekisteri vastaa kutsujalle lähettämällä palan WSDL-määrittelystä. Tämän jälkeen, mikäli palautettiin oikeanlaista tietoa, asiakkaalla on kaikki
  tarpeellinen tieto linkittyäkseen palveluun. Saamansa WSDL:n avulla asiakas tekee pyynnön palveluntarjoajalle, joka antaa edelleen WSDL-määritellyssä muodossa vastauksen asiakkaalle. Kaikki nämä pyynnöt palveluntarjoajan, rekisterin ja asiakkaan välillä ovat perinteisessä mallissa SOAP-muotoisia. Havainnollistus kuvassa 2.1. %[*lisää kuva perhana*]

Tällainen malli on hyvin perinteinen, oleellisina osina ovat WSDL, rekisterit ja SOAP viestit. On kehitetty myös muita tapoja keskustella palvelun ja asiakkaan välillä. Nykyään yhä useammat web-palvelut toteutetaan REST-tyyppisesti (citation needed). Ongelmaksi palvelun haun kannalta muodostuu se, ettei REST:ä ole standardoitu, eikä siis ole olemassa standardoitua tapaa miten palveluiden haku REST-tyyppisille rajapinnoilla toteutetaan. Normaalisti REST-tyyppisen palvelun haku perustuu sen URI:n. Esimerkiksi osoitteessa http://yhtio.com/api/kayttajat/ voisi listata kyseisen palvelun käyttäjät. On täysin palveluntarjoajan vastuulla, että asiakkaat löytävät kyseiset resurssit. Hyvässä tapauksessa resurssien metadatasta löytyy tietoa siitä mitä voidaan tehdä seuraavaksi tai mitä muita resursseja voidaan hakea. REST ei siis varsinaisesti ota kantaa miten palvelun haku on toteutettu.

Erinäisiä lähestymistapoja yhdistää REST:iä traditionaaliseen malliin kuitenkin löytyy. Eräs ohjelmointi- ja palvelunkoostamistapa, jossa kaikki yksittäiset palvelut ovat täysin hajautettuja ja jotka keskustelevat keskenään RESTmäisesti, ilman keskinäisiä palvelumäärityksiä ja sopimuksia, on mikropalveluarkkitehtuuri. Mikropalveluarkkitehtuuri on nimitys, jonka puolestapuhuja esimerkiksi Martin Fowler on. Käytännössä mikropalvelut ovat SOA arkkitehtuurin mukaisia, mutta eräät kokivat SOA:n terminä liian laveaksi ja monimerkitykselliseksi. Mikropalveluihin ei oletuksena kuulu rekisteriä, joten nämä tarvitsevat oman tapansa linkittää palvelun kutsuja sekä palvelun tarjoaja. Tällaisia ratkaisuja voivat olla vaikkapa selaimen tai palvelinpuolen palveluiden haku. Joka tapauksessa nämäkin ratkaisut päätyvät usein rekisterin käyttöön (esimerkiksi Netflix ja EUREKA viite). Ratkaisut loppuviimein ovat hyvin samanlaisia, erona on ettei REST-palvelunhakua ole standardoitu vielä samalla tavalla kuin Web Service maailmassa.

\subsection{Erilaisia rekistereitä}

Perinteisen Web service mallin palvelut nojaavat yleensä erilaisiin rekistereihin. OASIS kehitti UDDI:n vuonna 2000 siltä ideapohjalta, että palvelua käyttävät tahot linkitettäisiin palvelun tarjoajiin julkisen tai yksityisen rekisterin avulla. Tällaisessa visiossa kuka tahansa esimerkiksi luottokorttitunnistusta tarvitseva asiakas tekisi pyynnön palvelurekisteriä vastaan ja valitsisi oikean SOAP:ia tukevan palvelun. Tällaisessa maailmassa julkisesti ylläpidettävä UDDI-rekisteri olisi kriittisen tärkeä kaikille. UDDI ei kuitenkaan päätynyt niin yleiseen käyttöön kuin sen julkaisivat olisivat toivoneet ja sen kehittäminen loppui vuonna 2007 [https://lists.oasis-open.org/archives/uddi-spec/200807/msg00000.html]. Se on kuitenkin edelleen osa Web Services Interoperability standardia ja tärkeä osa perinteistä Web Service palvelunhakumallia.

UDDI-rekisteri koostuu kolmesta osasta:

\begin{itemize}

\item \textit{Valkoiset sivut} sisältävät tietoa palveluntarjoajasta. Tähän sisältyy esimerkiksi julkaisijan/yrityksen nimi ja kuvaus, mahdollisesti monella kielellä, ja palvelu voi olla löydettävissä pelkästään tämän tiedon avulla. Valkoiset sivut saattavat sisältää myös palveluntarjoajan yhteystiedot kuten puhelinnumero ja osoite.

\item \textit{Keltaiset sivut} luokittelevat palvelut standardoitujen taksonomioiden mukaan.\footnote{Standardoituja taksonomioita ovat esimerkiksi SIC (Standard Industrial Classification) ja NAICS (North American Industry Classification System)} Yhteen valkoiseen sivuun voi liittyä useampi keltainen sivu, eli kuvaukset useammalle palvelulle.

\item \textit{Vihreät sivut} sisältävät teknistä tietoa miten palveluun pääsee käsiksi. Sisältävät siis palvelun osoitteen, parametrit ja viitteet vaadittuihin rajapintoihin tai protokolliin joilla palvelu toimii.

\end{itemize}

\subsection{Palveluiden haun haasteet}

Web service -palveluhaun suurimpia ongelmia on, että se on kuin etsisi neulaa heinäsuovasta, varsinkin kun palveluiden määrä kasvaa. Oikean palvelun löytäminen käyttäjän antamien hakuehtojen mukaan on vieläkin perustavanlaatuinen tutkimusongelma SOC-maailmassa. 

Useat tekijät haastavat palvelun haun ongelmaa entisestään:

%heinäsuovasta = J. Garofalakis, Y. Panagis, E. Sakkopoulos, and
%A. Tsakalidis. Web Service Discovery Mechanisms:
%Looking for a Needle in a Haystack? In International
%Workshop on Web Engineering, 2004.

%SOC maailma Q. Li, A. Liu, H. Liu, B. Lin, L. Huang, and N. Gu.
%Web services provision: solutions, challenges and
%opportunities (invited paper). In ICUIMC ?09:
%Proceedings of the 3rd International Conference on
%Ubiquitous Information Management and

\begin{itemize}

\item Julkisten web palveluiden määrä kasvaa tasaisesti koko ajan, samalla kun pilvi- ja SaaS-palvelut ovat kasvattaneet suosiotaan. 

\item Avainsana-perustainen palvelun haku on ongelmallinen kahdessakin mielessä. Palveluntarjoajat julkaisevat usein puutteellisia palvelukuvauksia jotka eivät sovellu avainsana-hakuun. Lisäksi nykypäivän monimutkaiset liiketoimintatarpeet ylipäätään vaikeuttavat asiakkaan hakusanavalintaa.

\item Haku on syntaksiperustainen, joka johtaa semanttisuuden puutteeseen palvelun haussa.

\item välinpitämättömyys ohjelman toiminnan kannalta vähemmän oleellisiin asioihin, kuten palvelun laatuun ja hintaan.

\end{itemize}

Perinteisen mallin syntaktisuuteen perustuva palvelun haku aiheuttaa ongelmia.
Palvelua määritellessään julkaisijat sortuvat helposti XSD sekä WSDL-pohjaisiin antipatterneihin, jotka heikentävät palvelun haun tehokkuutta. Lähteessä [numero] mainitaan kahdeksan antipatternia ja ratkaisuja niihin:
\begin{itemize}

\item Puuttuvat tai virheelliset kommentit:

\item Monitulkintaiset XML-elementtien nimet:

\item Ylimääräiset port-type määritykset:

\item Pienen koheesion omaavat operaatiot samassa port-typessä:

\item Suljettu datamalli:

\item Ylimääräiset datamallit:

\item Turhan laaja tyyppikonteksti datatyypille:

\item Piilevät virheviestit standardiviesteissä:

\end{itemize}
%viite antipatterneihin Improving Web Service descriptions for effective service discovery Juan Manuel Rodriguez, Marco Crasso, Alejandro Zunino, Marcelo Campo

Tarve paranneltuihin palvelumäärityksiin on huomattu muualla tiedeyhteisössäkin.
%tiedeyhteisö huomaus  D. Kuropka, P. Tr¨oger, S. Staab, and M. Weske.
%Semantic Service Provisioning. Springer, Germany, 2008.
Todella paljon tutkimusta on tehty SOC:in palvelun haun ongelmien vastaamiseksi.
Ne voidaan jakaa neljään eri luokkaan.

\begin{enumerate}

\item Semanttiset lähestymistavat:

\item Informaation haku -lähestymistavat:

\item Data mining -lähestymistavat:

\item Linkittämiseen liittyvät lähestymistavat:

\end{enumerate}


Haasteeksi perinteisessä WSDL:n, rekisteriin ja SOAP:aan keskittyvässä mallissa on tullut semanttisuuden puute [viite Bringing Semantics to Web Services with OWL-S + A Method for Semantically Enhancing the Service Discovery Capabilities of UDDI], sillä WSDL kertoo kyllä miten palvelua käytetään, mutta ei tarjoa ratkaisuja siihen mitä tapahtuu kun palvelua käytetään. Palvelua käyttävä ihminen lukee sen luonnollisella kielellä palvelukuvauksesta. Jos halutaan automatisoituja palveluja, jotka osaavat luotettavasti ratkaista ongelmia, tarvitaan tapa jättää ihminen välistä. Tarvitaan siis jokin ratkaisu tuottamaan semanttisia palvelukuvauksia. Palveluiden haku on luonteeltaan semanttista, mutta perinteinen UDDI,SOAP,WSDL perustuvan mallin rajoitteena on kertoa mitä kaikkea palvelu pystyy tekemään. Malli on luonteeltaan syntaksipohjainen, joka ei pysty itsessään ilmaisemaan koko kontekstia, jossa palvelut toimivat ja mitä ne pystyvät tekemään.

UDDI:n avulla kyselyt palauttavat usein vääriä palveluita,
%viite Composition-oriented Service Discovery
%Antonio Brogi, Sara Corfini, Razvan Popescu
%Department of Computer Science
%University of Pisa, Italy
varsinkin kun palveluiden määrä rekisterissä kasvaa.


Erilaisia lähestymistapoja asian korjaamiseksi on esitetty. Esittelyt löytyvät kohdasta "Semanttinen palveluiden haku".
%viite johonkin OWL settiin vaikka

\subsection{Semanttinen palveluiden haku}

Palveluiden haku myös semanttisen webin saralla on perustavanlaatuinen tutkimusongelma. Semanttiset palvelut ovat visio arkkitehtuurista, jossa käyttäjällä on mahdollisuus automaattisesti yhdistää tarvittavia palveluita toteuttaakseen jokin tietty tehtävä tai tehtäväkokonaisuus. Olkoon käyttäjä "Simo". Simo haluaa löytää halvan lennon määränpäähänsä josta haluaa jatkaa hotellille joka tyydyttää Simon tarpeet hinnaltaan ja sijainniltaan. Semanttisten web palveluiden visiona on yhdellä pyynnöllä yhdistellä palveluita, jotka antavat Simolle vastauksen haluttuun ongelmaan. Simo voisi hyvinkin olla myös muu e-Business palvelu, joka yhdistelee palveluita saadakseen ratkaisuja ongelmiinsa.

WSDL, SOAP ja UDDI standardit kärsivät semanttisen esityksen puutteesta, joten toive alan standardeilla koostettujen palveluiden automaattisesta integroimisesta jää täyttymättä. Jotta palveluista saataisiin kehitettyä semanttisia, on haasteita joihin täytyy löytää ratkaisu. Ensinnäkin kun palveluiden määrä lisääntyy merkittävästi, ja oikeiden palveluiden löytäminen on tärkeää, palvelunhaun tehokkuus ja tarkkuus tulee olla merkittävästi parempi kuin nyt. Toisekseen, kun palvelu saadaan tehokkaasti löydettyä, pitäisi pystyä automaattisesti linkittämään se kyseistä palvelua kutsuvaan palveluun. Molemmat näistä haasteista ovat riippuvaisia palveluntarjoajan kyvystä kuvata tarjoamansa palveluiden toiminnot sekä palveluita kutsuvien osapuolten kyvystä määritellä yksikäsitteisesti ja koneluettavasti tarpeensa palvelulta.

Eräs tapa lähestyä näitä haasteita, eli perinteisen mallin semanttisuuden lisäämistä on lisätä UDDI:in laajennus %viite A Method for Semantically Enhancing the Service Discovery Capabilities of UDDI 


%viite Semantic Web Services Discovery Regarded as a Constraint Satisfaction Problem
%Salima Benbernou, Etienne Canaud, Simone Pimont

\section{Yhteenveto}



%
% Sitten alkaa lähdeluettelo
%


\bibliographystyle{tktl}
%\bibliography{lahteet.bib}

\lastpage

\appendices

\pagestyle{empty}

\internalappendix{1}{Malli ABC}

Liitteet ovat tässä vain sisällysluettelon ja esitystavan mallina.
Jokainen liite aloitetaan yleensä uudelta sivulta, jonka alkuun tulee
liitteen numero ja nimi. Kunkin liitteen sivut numeroidaan erikseen.

Liite on paitsi dokumenttia täydentävä osuus myös itsenäinen
kokonaisuus. Liite ei siten voi olla pelkästään kuva tai ohjelmanpätkä,
vaan liitteessä on ilmaistava sen sisällön laatu ja tarkoitus.


\end{document}
